`timescale 1 ps / 1 ps

module MyTestbench();

  // Clock & reset
  logic clk;
  logic reset;

  // Signaux de contrôle du testbench
  logic [31:0] tb_WriteData;
  logic [12:0] tb_DataAdr;
  logic        tb_MemWrite;
  logic [31:0] tb_ReadData;

  // GPIO wires - séparation totale entrée/sortie
  logic [33:0] gpio_0_to_dut;     // Testbench ? DUT
  wire  [33:0] gpio_0_from_dut;   // DUT ? Testbench
  logic [33:0] gpio_1_to_dut;     // Testbench ? DUT
  logic [12:0] gpio_2_to_dut;     // Testbench ? DUT

  integer f;
  logic test_running;

  // Instantiate device under test
  MyDE0_Nano dut(
    .CLOCK_50(clk), 
    .GPIO_0_PI(gpio_0_from_dut),   // Sortie uniquement
    .GPIO_1(gpio_1_to_dut),         // Entrée uniquement
    .GPIO_2(gpio_2_to_dut)          // Entrée uniquement
  );

  // ============ CONNEXIONS SANS CONFLIT ============
  // Entrées au DUT
  assign gpio_1_to_dut[33]   = tb_MemWrite;
  assign gpio_1_to_dut[31:0] = tb_WriteData;
  assign gpio_1_to_dut[32]   = 1'b0;
  
  assign gpio_2_to_dut = tb_DataAdr;
  
  // Reset sur un GPIO séparé (pas utilisé par SPI)
  assign gpio_0_to_dut[0] = reset;
  assign gpio_0_to_dut[33:1] = 33'b0;  // Reste à 0

  // Sortie du DUT ? Testbench
  assign tb_ReadData = gpio_0_from_dut[32:1];
  // ================================================

  // Initialize test
  initial begin
    test_running = 1;
    f = $fopen("student_simul.txt", "w");
    
    // Initialiser
    tb_MemWrite  = 0;
    tb_DataAdr   = 0;
    tb_WriteData = 0;
    
    // Reset
    reset = 1; 
    #20; 
    reset = 0; 
    #20;
    
    $display("=== Starting FPU Test ===");
    $fwrite(f, "=== Starting FPU Test ===\n");

    // Écrire A = 10
    @(negedge clk);
    tb_DataAdr   = 13'h0600;
    tb_WriteData = 32'd10;
    tb_MemWrite  = 1;
    $display("Time %0t: Writing A=10 to 0x600", $time);

    // Écrire B = 20
    @(negedge clk);
    tb_DataAdr   = 13'h0604;
    tb_WriteData = 32'd20;
    tb_MemWrite  = 1;
    $display("Time %0t: Writing B=20 to 0x604", $time);

    // Écrire CMD = 1
    @(negedge clk);
    tb_DataAdr   = 13'h0608;
    tb_WriteData = 32'd1;
    tb_MemWrite  = 1;
    $display("Time %0t: Writing CMD=1 to 0x608", $time);

    // Arrêter écriture
    @(negedge clk);
    tb_MemWrite  = 0;
    
    // Attendre que le calcul se fasse
    repeat(3) @(negedge clk);

    // Lire résultat
    tb_DataAdr   = 13'h060C;
    @(negedge clk);
    #1;  // Délai pour propagation combinatoire
    
    $display("Time %0t: tb_ReadData = %d (expected 30)", $time, tb_ReadData);
    $fwrite(f, "\nFPU result: %d\n", tb_ReadData);
    
    // Vérification
    if (tb_ReadData === 32'd30) begin
        $display("*** TEST PASSED ***");
        $fwrite(f, "*** TEST PASSED ***\n");
    end else if (tb_ReadData === 32'bx || tb_ReadData === 32'bz) begin
        $display("*** TEST FAILED - ReadData is undefined (X or Z) ***");
        $fwrite(f, "*** TEST FAILED - ReadData is X/Z ***\n");
    end else begin
        $display("*** TEST FAILED - Expected 30, got %d ***", tb_ReadData);
        $fwrite(f, "*** TEST FAILED - Expected 30, got %d ***\n", tb_ReadData);
    end

    #100;
    $display("=== Test Complete ===");
    
    test_running = 0;
    $fclose(f);
    $stop;
  end

  // Generate clock
  always begin
    clk = 1; #5; 
    clk = 0; #5;
  end

  // Log
  always @(negedge clk) begin
    if (test_running && reset == 0) begin
      $fwrite(f, "Time=%0t Addr=%h WData=%d RData=%d WE=%b\n", 
              $time, tb_DataAdr, tb_WriteData, tb_ReadData, tb_MemWrite);
    end
  end

endmodule