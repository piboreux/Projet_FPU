`timescale 1 ps / 1 ps

module MyTestbench();

  // Clock & reset
  logic        clk;
  logic        reset;

  // Bus avec la carte
  logic [31:0] ReadData;
  logic [31:0] WriteData;
  logic [12:0] DataAdr;
  logic        MemWrite;

  wire [33:0]	GPIO_0_PI;
  wire [33:0]	GPIO_1;
  wire [12:0]	GPIO_2;

  integer f;

  // Instantiate device under test
  MyDE0_Nano dut(
    .CLOCK_50(clk), 
    .GPIO_0_PI(GPIO_0_PI),
    .GPIO_1(GPIO_1),  
    .GPIO_2(GPIO_2)
  );

  // Connect testbench signals to DUT
  assign GPIO_0_PI[1] = reset;
  assign MemWrite      = GPIO_1[33];
  assign WriteData     = GPIO_1[31:0];  // 32-bit pour FPU
  assign DataAdr       = GPIO_2;
  assign ReadData      = GPIO_1[31:0];  // Lire 32 bits du FPU

  // Initialize test
  initial begin
    f = $fopen("student_simul.txt", "w");
    
    // Reset DUT
    reset <= 1; # 20; 
    reset <= 0; # 20;

    // ---------- TEST FPU ----------
    // Exemple : addition A + B
    // Écrire opérande A
    DataAdr   <= 13'h0600;   // Adresse FPU pour operande A
    WriteData <= 32'd10;     // Valeur A = 10
    @(negedge clk);

    // Écrire opérande B
    DataAdr   <= 13'h0604;   // Adresse FPU pour operande B
    WriteData <= 32'd20;     // Valeur B = 20
    @(negedge clk);

    // Déclencher le calcul (supposons registre de commande à 0x0608)
    DataAdr   <= 13'h0608;   
    WriteData <= 32'd1;      // Commande : addition
    @(negedge clk);

    // Attendre un cycle pour calculer
    @(negedge clk);

    // Lire le résultat
    DataAdr <= 13'h060C;     // Adresse FPU pour résultat
    @(negedge clk);
    $display("FPU result: %d", ReadData);
    $fwrite(f, "FPU result: %d\n", ReadData);

    $stop;
  end

  // Generate clock
  always begin
    clk <= 1; #5; clk <= 0; #5;
  end

  // Log all bus activity
  always @(negedge clk) begin
    $fwrite(f, "Addr: %h, WriteData: %h, ReadData: %h, MemWrite: %b\n", DataAdr, WriteData, ReadData, MemWrite);
  end

endmodule